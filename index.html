<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <title>Planet Water Volume Explorer</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <script src="https://cdn.plot.ly/plotly-2.24.1.min.js"></script>
  <style>
    body { font-family: Arial, sans-serif; background: #111; color: #eee; margin: 20px; }
    select, input[type=range] { width: 200px; }
    label { display: block; margin-top: 10px; }
    #plot { height: 700px; margin-top: 20px; }

    /* Container for button and info side by side */
    #controls {
      display: flex;
      align-items: center;
      gap: 20px;
      margin-top: 20px;
      flex-wrap: wrap;
    }
    #renderBtn {
      padding: 8px 16px;
      font-size: 16px;
      cursor: pointer;
      background-color: #09f;
      border: none;
      border-radius: 4px;
      color: white;
    }
    #renderBtn:hover {
      background-color: #06c;
    }
    #volumeInfo {
      font-size: 14px;
      line-height: 1.4;
      color: #ccc;
      white-space: nowrap;
    }

    #spinner {
      display: none;
      margin-left: 15px;
      border: 8px solid #333;
      border-top: 8px solid #09f;
      border-radius: 50%;
      width: 40px;
      height: 40px;
      animation: spin 1s linear infinite;
    }
    @keyframes spin {
      0% { transform: rotate(0deg);}
      100% { transform: rotate(360deg);}
    }
  </style>
</head>
<body>

<h2>Planet Water Volume Explorer</h2>

<label>
  Planet:
  <select id="planetSelect">
    <option value="earth" selected>Earth</option>
    <option value="venus">Venus</option>
    <option value="mars">Mars</option>
  </select>
</label>

<label>
  Percent surface covered with water: <span id="pctLabel">70%</span>
  <input id="pct" type="range" min="0" max="100" value="70">
</label>

<label>
  Sigma (Gaussian smoothing): <span id="sigmaLabel">1.0</span>
  <input id="sigma" type="range" min="0" max="10" step="0.1" value="1.0">
</label>

<label>
  View:
  <select id="viewMode">
    <option value="2d" selected>2D map</option>
    <option value="3d">3D globe</option>
  </select>
</label>

<div id="controls">
  <button id="renderBtn">Render</button>
  <div id="volumeInfo">
    Volume: —<br/>
    Ratio to Earth's oceans: —
  </div>
  <div id="spinner"></div>
</div>

<div id="plot"></div>

<script>
const planetFiles = {
  earth: "data/world/etopo10_bedrock.xyz",
  venus: "data/venus/MagellanReduced3-3.xyz",
  mars: "data/mars/megt90n000cb.xyz"
};
const planetRadii = {
  earth: 6378.14e3,
  venus: 6051.8e3,
  mars: 3389.5e3
};
const earthOceanKm3 = 1.332e9;

const spinner = document.getElementById('spinner');
const plotDiv = document.getElementById('plot');
const volumeInfo = document.getElementById('volumeInfo');

document.getElementById("pct").oninput = e => {
  document.getElementById("pctLabel").textContent = e.target.value + "%";
};
document.getElementById("sigma").oninput = e => {
  document.getElementById("sigmaLabel").textContent = parseFloat(e.target.value).toFixed(1);
};

document.getElementById("renderBtn").onclick = () => {
  const planet = document.getElementById("planetSelect").value;
  const pct = +document.getElementById("pct").value / 100;
  const sigma = +document.getElementById("sigma").value;
  const view = document.getElementById("viewMode").value;

  spinner.style.display = 'inline-block';
  volumeInfo.textContent = 'Calculating...';
  plotDiv.innerHTML = '';

  fetch(planetFiles[planet])
    .then(res => res.text())
    .then(text => {
      const rows = text.trim().split(/\n+/).map(line => line.trim().split(/\s+/).map(Number));

      let lonVals = rows.map(r => r[0]);
      let latVals = rows.map(r => r[1]);
      const R = planetRadii[planet];

      if(planet === 'mars') {
        lonVals = lonVals.map(v => v * 180 / (Math.PI * R));
        latVals = latVals.map(v => v * 180 / (Math.PI * R));
        for(let i=0; i<rows.length; i++){
          rows[i][0] = lonVals[i];
          rows[i][1] = latVals[i];
        }
      }

      const lons = Array.from(new Set(lonVals)).sort((a,b)=>a-b);
      const lats = Array.from(new Set(latVals)).sort((a,b)=>a-b);

      // Build elevation grid Z
      const Z = Array.from({length:lats.length}, () => Array(lons.length).fill(NaN));
      const lonIdx = new Map(lons.map((v,i)=>[v,i]));
      const latIdx = new Map(lats.map((v,i)=>[v,i]));
      for (const [lon, lat, alt] of rows) {
        Z[latIdx.get(lat)][lonIdx.get(lon)] = alt;
      }

      const blurred = gaussianBlur(Z, sigma);

      const allVals = blurred.flat().filter(v => !isNaN(v));
      const seaLevel = quantile(allVals, pct);

      const deg2rad = Math.PI / 180;
      const dlon = Math.abs(lons[1] - lons[0]);
      const dlat = Math.abs(lats[1] - lats[0]);
      const meanCellArea = (R**2) * deg2rad * dlon * deg2rad * dlat;
      let totalVolumeM3 = 0;
      for (let i=0; i<rows.length; i++) {
        const lat = rows[i][1];
        const depth = Math.max(0, seaLevel - rows[i][2]);
        const weight = Math.cos(lat * deg2rad);
        totalVolumeM3 += depth * meanCellArea * weight;
      }
      const totalKm3 = totalVolumeM3 / 1e9;
      const ratio = totalKm3 / earthOceanKm3;

      volumeInfo.innerHTML = `Volume: ~${totalKm3.toFixed(1)} km³<br/>Ratio to Earth's oceans: ~${ratio.toFixed(3)}×`;

      if(view === "3d") {
        plot3D(lons, lats, blurred, seaLevel, R, planet);
      } else {
        plot2D(lons, lats, blurred, seaLevel, planet);
      }
    })
    .catch(e => {
      alert("Error loading or processing data: " + e.message);
      spinner.style.display = 'none';
      volumeInfo.textContent = 'Error';
    });
};


// === PLOT 3D ===
function plot3D(lons, lats, Z, seaLevel, R, planet){
  const latRad = lats.map(d => d * Math.PI / 180);
  const lonRad = lons.map(d => d * Math.PI / 180);

  const latGrid = [], lonGrid = [], rGrid = [];
  for(let i=0; i<lats.length; i++){
    const latRow = [], lonRow = [], rRow = [];
    for(let j=0; j<lons.length; j++){
      latRow.push(latRad[i]);
      lonRow.push(lonRad[j]);
      rRow.push(R + (Z[i][j] - seaLevel));
    }
    latGrid.push(latRow);
    lonGrid.push(lonRow);
    rGrid.push(rRow);
  }

  const x = [], y = [], z = [];
  for(let i=0; i<lats.length; i++){
    const rowX = [], rowY = [], rowZ = [];
    for(let j=0; j<lons.length; j++){
      rowX.push(rGrid[i][j] * Math.cos(latGrid[i][j]) * Math.cos(lonGrid[i][j]));
      rowY.push(rGrid[i][j] * Math.cos(latGrid[i][j]) * Math.sin(lonGrid[i][j]));
      rowZ.push(rGrid[i][j] * Math.sin(latGrid[i][j]));
    }
    x.push(rowX); y.push(rowY); z.push(rowZ);
  }

  const zmin = safeMin(Z.map(row => row.map(v => v - seaLevel)));
  const zmax = safeMax(Z.map(row => row.map(v => v - seaLevel)));

  const breakpoint = (0 - zmin) / (zmax - zmin); // zero elevation breakpoint (sea level)

  const colorscale = [
    [0.0, 'rgb(0, 70, 140)'],
    [breakpoint, 'rgb(173, 216, 230)'],
    [breakpoint + 0.0001, 'rgb(36, 94, 43)'],
    [breakpoint + 0.4 * (1-breakpoint), 'rgb(160, 120, 90)'],
    [1.0, 'rgb(255, 255, 255)']
  ];

  const data = [{
    type: 'surface',
    x: x,
    y: y,
    z: z,
    surfacecolor: Z,
    colorscale: colorscale,
    cmin: zmin + seaLevel,
    cmax: zmax + seaLevel,
    showscale: true,
    colorbar: {
      title: 'Elevation (m)'
    }
  }];

  const layout = {
    title: planet.charAt(0).toUpperCase() + planet.slice(1) + ' 3D Elevation',
    scene: {
      aspectmode: 'data',
      camera: {
        eye: {x:1.5, y:1.5, z:0.5}
      }
    },
    hovermode: false,
    paper_bgcolor: '#111',
    plot_bgcolor: '#111',
    font: {color: '#eee'}
  };

  Plotly.newPlot(plotDiv, data, layout);
  spinner.style.display = 'none';
}

// === PLOT 2D ===
function plot2D(lons, lats, Z, seaLevel, planet){
  const water = Z.map(row => row.map(v => v <= seaLevel ? v : NaN));
  const land = Z.map(row => row.map(v => v > seaLevel ? v : NaN));

  const zminWater = safeMin(water);
  const zmaxWater = seaLevel;
  const zminLand = seaLevel;
  const zmaxLand = safeMax(land);

  const waterColorscale = [
    [0, 'rgb(0, 0, 139)'],
    [1, 'rgb(173, 216, 230)']
  ];
  const landColorscale = [
    [0, 'rgb(34,139,34)'],
    [1, 'rgb(205,133,63)']
  ];

  const data = [
    {
      z: water,
      x: lons,
      y: lats,
      type: 'heatmap',
      colorscale: waterColorscale,
      zmin: zminWater,
      zmax: zmaxWater,
      showscale: false,
      hoverinfo: 'none'
    },
    {
      z: land,
      x: lons,
      y: lats,
      type: 'heatmap',
      colorscale: landColorscale,
      zmin: zminLand,
      zmax: zmaxLand,
      showscale: false,
      hoverinfo: 'none'
    }
  ];

  const layout = {
    title: planet.charAt(0).toUpperCase() + planet.slice(1) + ' 2D Elevation Map',
    xaxis: {title: 'Longitude'},
    yaxis: {title: 'Latitude', scaleanchor: 'x'},
    paper_bgcolor: '#111',
    plot_bgcolor: '#111',
    font: {color: '#eee'}
  };

  Plotly.newPlot(plotDiv, data, layout);
  spinner.style.display = 'none';
}

function safeMin(arr){
  let min = Infinity;
  arr.flat(Infinity).forEach(v => {
    if(!isNaN(v) && v < min) min = v;
  });
  return min;
}
function safeMax(arr){
  let max = -Infinity;
  arr.flat(Infinity).forEach(v => {
    if(!isNaN(v) && v > max) max = v;
  });
  return max;
}

function quantile(arr, q){
  const sorted = arr.slice().sort((a,b)=>a-b);
  const pos = (sorted.length - 1) * q;
  const base = Math.floor(pos);
  const rest = pos - base;
  if(sorted[base+1] !== undefined){
    return sorted[base] + rest * (sorted[base+1] - sorted[base]);
  } else {
    return sorted[base];
  }
}

function gaussianBlur(Z, sigma){
  if(sigma < 0.01) return Z;
  const kernelSize = Math.max(3, Math.floor(sigma * 3) * 2 + 1);
  const kernel = [];
  const mean = Math.floor(kernelSize/2);
  let sum = 0;
  for(let x=0; x<kernelSize; x++){
    kernel[x] = [];
    for(let y=0; y<kernelSize; y++){
      const dx = x - mean;
      const dy = y - mean;
      const val = Math.exp(-(dx*dx + dy*dy)/(2*sigma*sigma));
      kernel[x][y] = val;
      sum += val;
    }
  }
  for(let x=0; x<kernelSize; x++){
    for(let y=0; y<kernelSize; y++){
      kernel[x][y] /= sum;
    }
  }

  const rows = Z.length;
  const cols = Z[0].length;
  const out = Array.from({length:rows}, () => Array(cols).fill(NaN));
  for(let i=0; i<rows; i++){
    for(let j=0; j<cols; j++){
      let acc = 0;
      let wsum = 0;
      for(let ki=0; ki<kernelSize; ki++){
        for(let kj=0; kj<kernelSize; kj++){
          const ii = i + ki - mean;
          const jj = j + kj - mean;
          if(ii >= 0 && ii < rows && jj >= 0 && jj < cols && !isNaN(Z[ii][jj])){
            acc += Z[ii][jj] * kernel[ki][kj];
            wsum += kernel[ki][kj];
          }
        }
      }
      out[i][j] = wsum ? acc / wsum : NaN;
    }
  }
  return out;
}
</script>

</body>
</html>
